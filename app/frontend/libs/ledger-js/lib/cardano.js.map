{"version":3,"sources":["../src/cardano.js"],"names":["HARDENED","parseBIP32Index","str","base","endsWith","slice","i","utils","safe_parseInt","Precondition","check","str_to_path","data","checkIsString","length","split","map","serializeAddressInfo","addressTypeNibble","networkIdOrProtocolMagic","spendingPath","stakingPath","stakingKeyHashHex","stakingBlockchainPointer","checkIsUint8","addressTypeNibbleBuf","uint8_to_buf","networkIdOrProtocolMagicBuf","AddressTypeNibbles","BYRON","checkIsUint32","uint32_to_buf","checkIsValidPath","spendingPathBuf","path_to_buf","stakingChoices","NO_STAKING","STAKING_KEY_PATH","STAKING_KEY_HASH","BLOCKCHAIN_POINTER","stakingChoice","stakingInfoBuf","Buffer","alloc","stakingKeyHash","hex_to_buf","blockIndex","writeUInt32BE","txIndex","certificateIndex","Error","stakingChoiceBuf","from","concat"],"mappings":"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","sourcesContent":["import utils, { Precondition } from \"./utils\";\nimport {AddressTypeNibbles} from './Ada';\n\nconst HARDENED = 0x80000000;\n\nfunction parseBIP32Index(str: string): number {\n  let base = 0;\n  if (str.endsWith(\"'\")) {\n    str = str.slice(0, -1);\n    base = HARDENED;\n  }\n  const i = utils.safe_parseInt(str);\n  Precondition.check(i >= 0);\n  Precondition.check(i < HARDENED);\n  return base + i;\n}\n  \nexport function str_to_path(data: string): Array<number> {\n  Precondition.checkIsString(data);\n  Precondition.check(data.length > 0);\n\n  return data.split(\"/\").map(parseBIP32Index);\n}\n\nexport function serializeAddressInfo(\n    addressTypeNibble: number,\n    networkIdOrProtocolMagic: number,\n    spendingPath: BIP32Path,\n    stakingPath: ?BIP32Path = null,\n    stakingKeyHashHex: ?string = null,\n    stakingBlockchainPointer: ?StakingBlockchainPointer = null\n): Buffer {\n  Precondition.checkIsUint8(addressTypeNibble << 4);\n  const addressTypeNibbleBuf = utils.uint8_to_buf(addressTypeNibble);\n\n  let networkIdOrProtocolMagicBuf;\n\n  if (addressTypeNibble == AddressTypeNibbles.BYRON) {\n    Precondition.checkIsUint32(networkIdOrProtocolMagic);\n    networkIdOrProtocolMagicBuf = utils.uint32_to_buf(networkIdOrProtocolMagic);\n  } else {\n    Precondition.checkIsUint8(networkIdOrProtocolMagic);\n    networkIdOrProtocolMagicBuf = utils.uint8_to_buf(networkIdOrProtocolMagic);\n  }\n\n  Precondition.checkIsValidPath(spendingPath);\n  const spendingPathBuf = utils.path_to_buf(spendingPath);\n\n  const stakingChoices = {\n    NO_STAKING: 0x11,\n    STAKING_KEY_PATH: 0x22,\n    STAKING_KEY_HASH: 0x33,\n    BLOCKCHAIN_POINTER: 0x44\n  };\n  type StakingChoice = $Values<typeof stakingChoices>;\n\n  // serialize staking info\n  let stakingChoice: StakingChoice;\n  let stakingInfoBuf: Buffer;\n  if (!stakingPath && !stakingKeyHashHex && !stakingBlockchainPointer) {\n    stakingChoice = stakingChoices.NO_STAKING;\n    stakingInfoBuf = Buffer.alloc(0);\n  } else if ( stakingPath && !stakingKeyHashHex && !stakingBlockchainPointer) {\n    stakingChoice = stakingChoices.STAKING_KEY_PATH;\n    Precondition.checkIsValidPath(stakingPath);\n    stakingInfoBuf = utils.path_to_buf(stakingPath);\n  } else if (!stakingPath &&  stakingKeyHashHex && !stakingBlockchainPointer) {\n    const stakingKeyHash = utils.hex_to_buf(stakingKeyHashHex);\n    stakingChoice = stakingChoices.STAKING_KEY_HASH;\n    Precondition.check(stakingKeyHash.length == 28); // TODO some global constant for key hash length\n    stakingInfoBuf = stakingKeyHash;\n  } else if (!stakingPath && !stakingKeyHashHex &&  stakingBlockchainPointer) {\n    stakingChoice = stakingChoices.BLOCKCHAIN_POINTER;\n    stakingInfoBuf = Buffer.alloc(3 * 4); // 3 x uint32\n    \n    Precondition.checkIsUint32(stakingBlockchainPointer.blockIndex);\n    stakingInfoBuf.writeUInt32BE(stakingBlockchainPointer.blockIndex, 0);\n    Precondition.checkIsUint32(stakingBlockchainPointer.txIndex);\n    stakingInfoBuf.writeUInt32BE(stakingBlockchainPointer.txIndex, 4);\n    Precondition.checkIsUint32(stakingBlockchainPointer.certificateIndex);\n    stakingInfoBuf.writeUInt32BE(stakingBlockchainPointer.certificateIndex, 8);\n  } else {\n    throw new Error(\"Invalid staking info\");\n  }\n  const stakingChoiceBuf = Buffer.from([stakingChoice]);\n\n  return Buffer.concat([\n    addressTypeNibbleBuf,\n    networkIdOrProtocolMagicBuf,\n    spendingPathBuf,\n    stakingChoiceBuf,\n    stakingInfoBuf\n  ]);\n}\n  \nexport default {\n  HARDENED,\n\n  str_to_path,\n\n  serializeAddressInfo\n};\n"],"file":"cardano.js"}