{"version":3,"sources":["../src/utils.js"],"names":["BASE58_ALPHABET","bs58","BECH32_ALPHABET","bs10","MAX_LOVELACE_SUPPLY_STR","join","TESTNET_NETWORK_ID","Precondition","check","cond","Error","checkIsString","data","checkIsInteger","Number","isInteger","checkIsArray","Array","isArray","checkIsBuffer","Buffer","isBuffer","checkIsUint32","checkIsUint8","checkIsHexString","length","test","checkIsValidPath","path","x","checkIsValidAmount","amount","checkIsValidBase58","c","includes","checkIsValidBech32Address","split","Assert","assert","uint32_to_buf","value","alloc","writeUInt32BE","buf_to_uint32","readUIntBE","uint8_to_buf","writeUInt8","hex_to_buf","from","buf_to_hex","toString","path_to_buf","i","sum","arr","reduce","y","chunkBy","chunkLengths","len","offset","result","restLength","push","slice","stripRetcodeFromResponse","response","L","retcode","buf_to_amount","encoded","encode","replace","amount_to_buf","decode","padding","concat","base58_encode","base58_decode","bech32_encodeAddress","networkId","data5bit","bech32","toWords","MAX_HUMAN_ADDRESS_LENGTH","getShelleyAddressPrefix","addressType","AddressTypeNibbles","REWARD","bech32_decodeAddress","words","fromWords","safe_parseInt","str","parseInt","isNaN"],"mappings":"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","sourcesContent":["//@flow\nimport basex from \"base-x\";\nimport bech32 from \"bech32\";\nimport {AddressTypeNibbles} from \"./Ada\"\n\nconst BASE58_ALPHABET =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nconst bs58 = basex(BASE58_ALPHABET);\n\nconst BECH32_ALPHABET =\n  \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n\n// We use bs10 as an easy way to parse/encode amount strings\nconst bs10 = basex(\"0123456789\");\n\n// Max supply in lovelace\nconst MAX_LOVELACE_SUPPLY_STR = [\"45\", \"000\", \"000\", \"000\", \"000000\"].join(\"\");\n\nconst TESTNET_NETWORK_ID = 0x00\n\nexport const Precondition = {\n  // Generic check\n  check: (cond: boolean) => {\n    if (!cond) throw new Error(\"Precondition failed\");\n  },\n  // Basic types\n  checkIsString: (data: any) => {\n    Precondition.check(typeof data === \"string\");\n  },\n  checkIsInteger: (data: any) => {\n    Precondition.check(Number.isInteger(data));\n  },\n  checkIsArray: (data: any) => {\n    Precondition.check(Array.isArray(data));\n  },\n  checkIsBuffer: (data: any) => {\n    Precondition.check(Buffer.isBuffer(data));\n  },\n\n  // Extended checks\n  checkIsUint32: (data: any) => {\n    Precondition.checkIsInteger(data);\n    Precondition.check(data >= 0);\n    Precondition.check(data <= 4294967295);\n  },\n  checkIsUint8: (data: any) => {\n    Precondition.checkIsInteger(data);\n    Precondition.check(data >= 0);\n    Precondition.check(data <= 255);\n  },\n\n  checkIsHexString: (data: any) => {\n    Precondition.checkIsString(data);\n    Precondition.check(data.length % 2 == 0);\n    Precondition.check(/^[0-9a-fA-F]*$/.test(data));\n  },\n  checkIsValidPath: (path: Array<number>) => {\n    Precondition.checkIsArray(path);\n    for (const x of path) {\n      Precondition.checkIsUint32(x);\n    }\n  },\n  checkIsValidAmount: (amount: string) => {\n    Precondition.checkIsString(amount);\n    Precondition.check(/^[0-9]*$/.test(amount));\n    // Length checks\n    Precondition.check(amount.length > 0);\n    Precondition.check(amount.length <= MAX_LOVELACE_SUPPLY_STR.length);\n    // Leading zeros\n    if (amount.length > 1) {\n      Precondition.check(amount[0] != \"0\");\n    }\n    // less than max supply\n    if (amount.length == MAX_LOVELACE_SUPPLY_STR.length) {\n      // Note: this is string comparison!\n      Precondition.check(amount <= MAX_LOVELACE_SUPPLY_STR);\n    }\n  },\n  checkIsValidBase58: (data: string) => {\n    Precondition.checkIsString(data);\n    for (const c of data) {\n      Precondition.check(BASE58_ALPHABET.includes(c));\n    }\n  },\n  checkIsValidBech32Address: (data: string) => {\n    Precondition.checkIsString(data);\n    Precondition.check(data.split(\"1\").length == 2);\n\n    for (const c of data.split(\"1\")[1]) {\n      Precondition.check(BECH32_ALPHABET.includes(c));\n    }\n  }\n};\n\nexport const Assert = {\n  assert: (cond: boolean) => {\n    if (!cond) throw new Error(\"Assertion failed\");\n  }\n};\n\nexport function uint32_to_buf(value: number): Buffer {\n  Precondition.checkIsUint32(value);\n\n  const data = Buffer.alloc(4);\n  data.writeUInt32BE(value, 0);\n  return data;\n}\n\nexport function buf_to_uint32(data: Buffer): number {\n  Precondition.check(data.length == 4);\n\n  return data.readUIntBE(0, 4);\n}\n\nexport function uint8_to_buf(value: number): Buffer {\n  Precondition.checkIsUint8(value);\n\n  const data = Buffer.alloc(1);\n  data.writeUInt8(value, 0);\n  return data;\n}\n\nexport function hex_to_buf(data: string): Buffer {\n  Precondition.checkIsHexString(data);\n  return Buffer.from(data, \"hex\");\n}\n\nexport function buf_to_hex(data: Buffer): string {\n  return data.toString(\"hex\");\n}\n\n// no buf_to_uint8\n\nexport function path_to_buf(path: Array<number>): Buffer {\n  Precondition.checkIsValidPath(path);\n\n  const data = Buffer.alloc(1 + 4 * path.length);\n  data.writeUInt8(path.length, 0);\n\n  for (let i = 0; i < path.length; i++) {\n    data.writeUInt32BE(path[i], 1 + i * 4);\n  }\n  return data;\n}\n\nconst sum = (arr: Array<number>) => arr.reduce((x, y) => x + y, 0);\n\nexport function chunkBy(data: Buffer, chunkLengths: Array<number>) {\n  Precondition.checkIsBuffer(data);\n  Precondition.checkIsArray(chunkLengths);\n  for (const len of chunkLengths) {\n    Precondition.checkIsInteger(len);\n    Precondition.check(len > 0);\n  }\n  Precondition.check(data.length <= sum(chunkLengths));\n\n  let offset = 0;\n  const result = [];\n\n  const restLength = data.length - sum(chunkLengths);\n\n  for (let c of [...chunkLengths, restLength]) {\n    result.push(data.slice(offset, offset + c));\n\n    offset += c;\n  }\n\n  return result;\n}\n\nexport function stripRetcodeFromResponse(response: Buffer): Buffer {\n  Precondition.checkIsBuffer(response);\n  Precondition.check(response.length >= 2);\n\n  const L = response.length - 2;\n  const retcode = response.slice(L, L + 2);\n\n  if (retcode.toString(\"hex\") != \"9000\")\n    throw new Error(`Invalid retcode ${retcode.toString(\"hex\")}`);\n  return response.slice(0, L);\n}\n\nexport function buf_to_amount(data: Buffer): string {\n  Precondition.checkIsBuffer(data);\n  Precondition.check(data.length == 8);\n\n  const encoded = bs10.encode(data);\n  // Strip leading zeros\n  return encoded.replace(/^0*(.)/, \"$1\");\n}\n\nexport function amount_to_buf(amount: string): Buffer {\n  Precondition.checkIsValidAmount(amount);\n\n  const data = bs10.decode(amount);\n  // Amount should fit uin64_t\n  Assert.assert(data.length <= 8);\n\n  const padding = Buffer.alloc(8 - data.length);\n  return Buffer.concat([padding, data]);\n}\n\nexport function base58_encode(data: Buffer): string {\n  Precondition.checkIsBuffer(data);\n\n  return bs58.encode(data);\n}\n\nexport function base58_decode(data: string): Buffer {\n  Precondition.checkIsValidBase58(data);\n\n  return bs58.decode(data);\n}\n\nexport function bech32_encodeAddress(data: Buffer): string {\n  Precondition.checkIsBuffer(data);\n\n  const networkId = data[0] & 0b00001111;\n\n  const data5bit = bech32.toWords(data);\n  const MAX_HUMAN_ADDRESS_LENGTH = 150; // see cardano.h in https://github.com/vacuumlabs/ledger-app-cardano-shelley\n  return bech32.encode(getShelleyAddressPrefix(data), data5bit, MAX_HUMAN_ADDRESS_LENGTH);\n}\n\n// based on https://github.com/cardano-foundation/CIPs/pull/6/files\nfunction getShelleyAddressPrefix(data: Buffer): string {\n  let result = \"\";\n\n  const addressType = (data[0] & 0b11110000) >> 4;\n  switch (addressType) {\n    case AddressTypeNibbles.REWARD:\n      result = \"stake\";\n      break;\n    default:\n      result = \"addr\";\n  }\n\n  const networkId = data[0] & 0b00001111;\n  if (networkId === TESTNET_NETWORK_ID) {\n      result += \"_test\";\n  }\n\n  return result;\n}\n\nexport function bech32_decodeAddress(data: string): Buffer {\n  Precondition.checkIsValidBech32Address(data);\n\n  const { words } = bech32.decode(data, 1000)\n  return Buffer.from(bech32.fromWords(words));\n}\n\nexport function safe_parseInt(str: string): number {\n  Precondition.checkIsString(str);\n  const i = parseInt(str);\n  // Check that we parsed everything\n  Precondition.check(\"\" + i == str);\n  // Could be invalid\n  Precondition.check(!isNaN(i));\n  // Could still be float\n  Precondition.checkIsInteger(i);\n  return i;\n}\n\n\n\nexport default {\n  hex_to_buf,\n  buf_to_hex,\n\n  uint32_to_buf,\n  buf_to_uint32,\n\n  // no pair for now\n  uint8_to_buf,\n\n  // no pair for now\n  path_to_buf,\n\n  safe_parseInt,\n\n  amount_to_buf,\n  buf_to_amount,\n\n  base58_encode,\n  base58_decode,\n\n  bech32_encodeAddress,\n  bech32_decodeAddress,\n\n  safe_parseInt,\n  chunkBy,\n  stripRetcodeFromResponse\n};\n"],"file":"utils.js"}